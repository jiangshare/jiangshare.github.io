<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>算子融合的模型推导 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="在将深度学习模型部署到资源受限的嵌入式设备时，模型量化作为模型压缩的核心技术，对实现高效推理至关重要。尽管主流开发板厂商通常提供专用的量化工具链以简化部署流程，但在缺乏官方支持的开源硬件或定制化场景下，开发者需要自主构建完整的量化解决方案。本文以多层感知机（MLP）为研究对象，基于ReLU激活函数的特性，重点探讨静态量化（Static PTQ）中的线性非对称映射方法(映射到[0,255])，系统性">
<meta property="og:type" content="article">
<meta property="og:title" content="算子融合的模型推导">
<meta property="og:url" content="http://example.com/2025/07/28/%E9%87%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在将深度学习模型部署到资源受限的嵌入式设备时，模型量化作为模型压缩的核心技术，对实现高效推理至关重要。尽管主流开发板厂商通常提供专用的量化工具链以简化部署流程，但在缺乏官方支持的开源硬件或定制化场景下，开发者需要自主构建完整的量化解决方案。本文以多层感知机（MLP）为研究对象，基于ReLU激活函数的特性，重点探讨静态量化（Static PTQ）中的线性非对称映射方法(映射到[0,255])，系统性">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-28T12:38:29.454Z">
<meta property="article:modified_time" content="2025-07-31T07:05:10.874Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-量化模型推理算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/28/%E9%87%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-07-28T12:38:29.454Z" itemprop="datePublished">2025-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      算子融合的模型推导
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在将深度学习模型部署到资源受限的嵌入式设备时，模型量化作为模型压缩的核心技术，对实现高效推理至关重要。尽管主流开发板厂商通常提供专用的量化工具链以简化部署流程，但在缺乏官方支持的开源硬件或定制化场景下，开发者需要自主构建完整的量化解决方案。本文以多层感知机（MLP）为研究对象，基于ReLU激活函数的特性，重点探讨静态量化（Static PTQ）中的线性非对称映射方法(映射到[0,255])，系统性地阐述从浮点模型到整型量化的完整实现路径，并深入分析在嵌入式设备上优化推理效率的工程实践方案。</p>
<h2 id="一、模型量化的系统框架"><a href="#一、模型量化的系统框架" class="headerlink" title="一、模型量化的系统框架"></a>一、模型量化的系统框架</h2><p>若对模型量化原理不太清楚的，可以参见<a target="_blank" rel="noopener" href="https://robot9.me/ai-model-quantization-principles-practice/">模型量化原理与实践 – Robot 9</a></p>
<h2 id="二、单层线性层"><a href="#二、单层线性层" class="headerlink" title="二、单层线性层"></a>二、单层线性层</h2><p>单层的数学模型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = Relu(wx + b)----(1)</span><br></pre></td></tr></table></figure>

<p>其中w为训练好的权重矩阵，x为输入，b为偏置，y为输出。选择一组校验数据X，用以确定X的scale 和 zero_point。具体计算方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_&#123;max&#125;=argmax(x)_&#123;x\in X&#125;,x_&#123;min&#125;=argmin(x)_&#123;x\in X&#125;</span><br></pre></td></tr></table></figure>

<p>则映射方案如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_&#123;x&#125;=\frac&#123;x_&#123;max&#125;-x_&#123;min&#125;&#125;&#123;255-0&#125;,z_x = 0 - \frac&#123;x_&#123;min&#125;&#125;&#123;s_x&#125;,x^m=\frac&#123;x&#125;&#123;s_x&#125;+z_x,</span><br></pre></td></tr></table></figure>

<p>反推可得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=s_x(x^m - z_x)---(2)</span><br></pre></td></tr></table></figure>

<p>同样的，我们统计w的最大值和最小值，并同样放缩为uint8类型，即[0,255]下，则其映射方案为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_&#123;w&#125;=\frac&#123;w_&#123;max&#125;-w_&#123;min&#125;&#125;&#123;255-0&#125;,z_w = 0 - \frac&#123;w_&#123;min&#125;&#125;&#123;s_m&#125;,w^m=\frac&#123;w&#125;&#123;s_w&#125;+z_w,</span><br></pre></td></tr></table></figure>

<p>反推可得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w=s_w(w^m - z_w)---(3)</span><br></pre></td></tr></table></figure>

<p>结合(1)(2)(3)得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = Relu(s_w(w^m - z_w)s_x(x^m - z_x) + b)----(1)</span><br></pre></td></tr></table></figure>

<p>展开得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = Relu(s_xs_w(w^mx^m + \frac&#123;b&#125;&#123;s_xs_w&#125; - w^mz_x- z_wx^m+z_wz_x))</span><br></pre></td></tr></table></figure>

<p>注意，其中z_x展开为向量(维度同x)，z_w(维度同w)，令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b^m=\frac&#123;b&#125;&#123;s_xs_w&#125;</span><br></pre></td></tr></table></figure>

<p>则有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = Relu(s_xs_w(w^mx^m + b^m - w^mz_x- z_wx^m+z_wz_x))</span><br></pre></td></tr></table></figure>

<p>易知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_xs_w \geq 0</span><br></pre></td></tr></table></figure>

<p>则有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = s_xs_wRelu(w^mx^m + b^m - w^mz_x- z_wx^m+z_wz_x)---(4)</span><br></pre></td></tr></table></figure>

<p>继续化简，有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = s_xs_w(Relu(w^mx^m + b^m - z_wx^m)_&#123;w^mz_x  -z_xz_w&#125; - (w^mz_x-z_wz_x))---(5)</span><br></pre></td></tr></table></figure>

<p>其中，Relu(t)_a表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if\space t &gt; a, Relu(t)_a=t \\</span><br><span class="line">else\space Relu(t)_a = a \space\space\space\space\space\space\space\space</span><br></pre></td></tr></table></figure>

<p>若设</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_&#123;x_1&#125;=s_xs_w,\space z_&#123;x_1&#125;=w^mz_x-z_wz_x,\space x_1=Relu(w^mx^m + b^m - z_wx^m)_&#123;z_&#123;x_1&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>则对于任意一个量化输出x_1，可得其反量化输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=s_&#123;x_1&#125;(x_1-z_&#123;x_1&#125;)---(6)</span><br></pre></td></tr></table></figure>

<p>而其中的量化输出，可由量化融合算子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Relu(w^mx^m + b^m - z_wx^m)_&#123;z_&#123;x_1&#125;&#125;---（7）</span><br></pre></td></tr></table></figure>

<p>基于量化输入x^m获得.</p>
<p>对于式(6)，其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_&#123;x_1&#125;和z_&#123;x_1&#125;</span><br></pre></td></tr></table></figure>

<p>可以提前计算，这加速了推理。</p>
<h3 id="三、溢出风险"><a href="#三、溢出风险" class="headerlink" title="三、溢出风险"></a>三、溢出风险</h3><p>注意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^mw^m + b^m</span><br></pre></td></tr></table></figure>

<p>有可能超出int8的范围，因此最好设置x^m为int32类型(也可设x^m为int16类型，b^m为int32类型)</p>
<h3 id="四、多层"><a href="#四、多层" class="headerlink" title="四、多层"></a>四、多层</h3><p>仔细观察，可以发现，式(6)似乎形式上类似于(2)，但是这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z_&#123;x_1&#125;为向量</span><br></pre></td></tr></table></figure>

<p>若我们初始的时候就令(2)中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z_x和w_x为向量，即对输入的各个维度的元素做映射---(8)</span><br></pre></td></tr></table></figure>

<p>则可以把(6)当作对x_1的量化。这里(8)不会影响二的推导结论。因此多层线性层只需在最后一层进行反量化，中间层无需反量化处理，这可以大大提高运算速度。但是，注意x_1可能不满足uint8的取值范围，因此，我们需要对x_1做进一步放缩，通过校准数据统计x_1的取值范围，并进行映射，假设其映射参数为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_&#123;x_1&#125;&#x27;和z_&#123;x_1&#125;&#x27; </span><br></pre></td></tr></table></figure>

<p>则由(6)可得，当前层的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = s_&#123;x_1&#125;(s&#x27;_&#123;x_1&#125;(x_1&#x27;^m-z&#x27;_&#123;x_1&#125;)-z_&#123;x_1&#125;)</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_1&#x27;^m = \frac&#123;x_1&#125;&#123;s&#x27;_&#123;x_1&#125;&#125;+z&#x27;_&#123;x_1&#125;</span><br></pre></td></tr></table></figure>

<p>简化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = s_&#123;x_1&#125;s&#x27;_&#123;x_1&#125;(x_1&#x27;^m-(\frac&#123;z_&#123;x_1&#125;&#125;&#123;s&#x27;_&#123;x_1&#125;&#125;+z&#x27;_&#123;x_1&#125;))</span><br></pre></td></tr></table></figure>

<p>因此这一层的输入的最后的映射参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=s_&#123;x_1&#125;s&#x27;_&#123;x_1&#125;,z=\frac&#123;z_&#123;x_1&#125;&#125;&#123;s&#x27;_&#123;x_1&#125;&#125;+z&#x27;_&#123;x_1&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个递推公式，已知上一层的输出映射参数，可以推得这一层的输入映射参数。将这一递推应用到所有层，则可以实现多层量化模型的推理。</p>
<p>五、最终方案：</p>
<p>(0)符号说明：</p>
<p>第i层的量化输入，量化输出，量化权重，量化偏置为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^m_&#123;ii&#125;,x^m_&#123;io&#125;,w^m_i,b^m_i</span><br></pre></td></tr></table></figure>

<p>各层的原权重和原偏置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w_i,b_i</span><br></pre></td></tr></table></figure>

<p>各层的量化输入，量化输出，量化权重，量化偏置的量化参数分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">量化输入：s_&#123;x_&#123;ii&#125;&#125;,z_&#123;x_&#123;ii&#125;&#125;\\</span><br><span class="line">量化输出：s_&#123;x_&#123;io&#125;&#125;,z_&#123;&#123;x_io&#125;&#125;\\</span><br><span class="line">量化权重：s_&#123;w_&#123;i&#125;&#125;,z_&#123;w_&#123;i&#125;&#125;\\</span><br><span class="line">量化偏置：s_&#123;b_&#123;i&#125;&#125;,z_&#123;b_&#123;i&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>(1)对于训练好的n层感知机(一层输入层，n-1层隐藏层)，统计其各层权重的s和z和量化权重，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_&#123;w_i&#125;,z_&#123;w_i&#125;,w^m_i</span><br></pre></td></tr></table></figure>

<p>(2)校验阶段引入校准数据x，对于第i层</p>
<p>​	0.有i-1层的量化输出及其量化参数为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^m_&#123;(i-1)o&#125;,s_&#123;x_&#123;(i-1)o&#125;&#125;,z_&#123;x_&#123;(i-1)o&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>​	1.若考虑对i-1层的量化输出再次量化，可得第i层的量化输入及其量化参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^m_&#123;ii&#125;=\frac&#123;x^m_&#123;(i-1)o&#125;&#125;&#123;s&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;&#125;+z&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;,s_&#123;x_&#123;ii&#125;&#125;=s_&#123;x_&#123;(i-1)o&#125;&#125;s&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;,z_&#123;x_&#123;ii&#125;&#125;=\frac&#123;z_&#123;x_&#123;(i-1)o&#125;&#125;&#125;&#123;s&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;&#125;+z&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>​	其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;和z&#x27;_&#123;x_&#123;(i-1)o&#125;&#125;为x^m_&#123;(i-1)o&#125;的统计值</span><br></pre></td></tr></table></figure>

<p>​	2.进而得到第i层量化偏置参数和量化参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b^m_i=\frac&#123;b_i&#125;&#123;s_&#123;x_&#123;ii&#125;&#125;s_&#123;w_i&#125;&#125;,s_&#123;b_i&#125;=s_&#123;x_&#123;ii&#125;&#125;s_&#123;w_i&#125;,z_&#123;b_i&#125;=0</span><br></pre></td></tr></table></figure>


<p>​	3.则可得第i层的量化输出及其量化参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_&#123;io&#125;^m=Relu(w_i^m*x^m_&#123;ii&#125;+b^m_i-z_&#123;w_i&#125;x^m_&#123;ii&#125;)_&#123;z_&#123;x_&#123;io&#125;&#125;&#125;,s_&#123;x_&#123;io&#125;&#125;=s_&#123;x_&#123;ii&#125;&#125;s_&#123;w_i&#125;,z_&#123;x_&#123;io&#125;&#125;=w^m_iz_&#123;x_&#123;ii&#125;&#125;-z_&#123;x_&#123;ii&#125;&#125;z_&#123;w_i&#125;</span><br></pre></td></tr></table></figure>

<p>初始时第0层的量化输出及对应的量化参数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^m_&#123;0o&#125;=x,s_&#123;x_&#123;0o&#125;&#125;=1,z_&#123;x_&#123;0o&#125;&#125;=0</span><br></pre></td></tr></table></figure>

<p>（3）推理阶段：经过(2)可得各层的量化参数，对于第k层</p>
<p>​	1.对k-1层的输出再次量化生成当前层的输入</p>
<p>​	2.通过量化后的线性层和激活函数算子获取第k层的量化输出</p>
<p>​	3.将当前层的量化输出导入到下一层</p>
<p>到最后一层时，通过最后一层的量化输出的量化参数做反量化处理，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = (x^m_&#123;no&#125;-z_&#123;x_&#123;no&#125;&#125;)s_&#123;x_&#123;no&#125;&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/28/%E9%87%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E7%AE%97%E6%B3%95/" data-id="cmdsaoz7k0000tsfmby8hb2db" data-title="算子融合的模型推导" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/28/%E9%87%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E7%AE%97%E6%B3%95/">算子融合的模型推导</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>